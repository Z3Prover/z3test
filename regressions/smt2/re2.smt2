(declare-const x String)
(declare-const y String)
(declare-const r (RegEx String))
(declare-const s (RegEx String))
(declare-const p (Array (_ BitVec 8) Bool)) ; predicate on characters

(echo "===== string in regex checks =====")

(echo "=== using empty string ===")

(echo "= atomic =")
; none, all, all single characters, character range, epsilon, predicate
(simplify (not (str.in_re "" re.empty)))
(simplify (not (str.in_re "" re.nostr)))
(simplify (str.in_re "" re.all))
(simplify (not (str.in_re "" re.allchar)))
(simplify (not (str.in_re "" (re.range "a" "a"))))
(simplify (not (str.in_re "" (re.range x x))))
(simplify (str.in_re "" (str.to_re "")))
(simplify (not (str.in_re "" (str.to_re "a"))))
(simplify (not (str.in_re "" (re.of.pred p))))

(echo "= standard constructors =")
; option, union, concat, star, plus
(simplify (str.in_re "" (re.opt r)))
(simplify (str.in_re "" (re.opt (str.to_re "a"))))
(simplify (str.in_re "" (re.opt (str.to_re ""))))
(simplify (str.in_re "" (re.union r (str.to_re ""))))
(simplify (not (str.in_re "" (re.union (str.to_re "a") (str.to_re "b")))))
(simplify (str.in_re "" (re.++ re.all (str.to_re ""))))
(simplify (str.in_re "" (re.++ (str.to_re "") (re.opt r))))
(simplify (not (str.in_re "" (re.++ (str.to_re "") re.allchar))))
(simplify (not (str.in_re "" (re.++ re.all re.empty))))
(simplify (not (str.in_re "" (re.++ (str.to_re "a") (str.to_re "")))))
(simplify (str.in_re "" (re.* r)))
(simplify (str.in_re "" (re.* (str.to_re "a"))))
(simplify (str.in_re "" (re.* (str.to_re ""))))
(simplify (str.in_re "" (re.* (re.of.pred p))))
(simplify (str.in_re "" (re.+ re.all)))
(simplify (not (str.in_re "" (re.+ (str.to_re "a")))))
(simplify (str.in_re "" (re.+ (str.to_re ""))))

(echo "= additional constructors =")
; additional constructors: complement, intersection
(simplify (str.in_re "" (re.complement re.allchar)))
(simplify (str.in_re "" (re.complement re.empty)))
(simplify (str.in_re "" (re.complement (str.to_re "a"))))
(simplify (str.in_re "" (re.complement (re.+ (str.to_re "a")))))
(simplify (not (str.in_re "" (re.complement re.all))))
(simplify (not (str.in_re "" (re.complement (str.to_re "")))))
(simplify (not (str.in_re "" (re.complement (re.opt r)))))
(simplify (str.in_re "" (re.inter re.all (str.to_re ""))))
(simplify (str.in_re "" (re.inter (str.to_re "") (str.to_re ""))))
(simplify (str.in_re "" (re.inter (str.to_re "") (re.opt r))))
(simplify (not (str.in_re "" (re.inter (str.to_re "") re.allchar))))
(simplify (not (str.in_re "" (re.inter re.all (str.to_re "a")))))
(simplify (not (str.in_re "" (re.inter re.empty (str.to_re "")))))
(simplify (not (str.in_re "" (re.inter (str.to_re "a") (str.to_re "b")))))

(echo "= looping (* with counting) =")
; loop between m and n times; or at least m times
(simplify (str.in_re "" ((_ re.loop 0 10) r)))
(simplify (str.in_re "" ((_ re.loop 0) r)))
(simplify (str.in_re "" ((_ re.loop 0) re.all)))
(simplify (str.in_re "" ((_ re.loop 1 3) (re.opt r))))
(simplify (str.in_re "" ((_ re.loop 2) re.all)))
(simplify (not (str.in_re "" ((_ re.loop 1 3) (str.to_re "a")))))
(simplify (not (str.in_re "" ((_ re.loop 1 0) (str.to_re "b")))))
(simplify (not (str.in_re "" ((_ re.loop 2) re.allchar))))
(simplify (not (str.in_re "" ((_ re.loop 3) (str.to_re "a")))))
; loop a fixed number of times
(simplify (str.in_re "" ((_ re.^ 0) r)))
(simplify (str.in_re "" ((_ re.^ 0) re.allchar)))
(simplify (str.in_re "" ((_ re.^ 1) (str.to_re ""))))
(simplify (not (str.in_re "" ((_ re.^ 1) re.allchar))))

(echo "= variations (not currently supported) =")
; empty string
(simplify (str.in_re "" re.emptystr))
; difference
(simplify (str.in_re "" (re.diff (str.to_re "") re.allchar)))
(simplify (str.in_re "" (re.diff (re.opt r) re.empty)))
(simplify (not (str.in_re "" (re.diff r r))))
(simplify (not (str.in_re "" (re.diff (str.to_re "") re.all))))
(simplify (not (str.in_re "" (re.diff (str.to_re "a") (str.to_re "a") ))))

(echo "= complex combinations =")
(echo "TODO")

(echo "=== using nonempty string ===")

(echo "= atomic =")
; none, all, all single characters, character range, epsilon, predicate
(simplify (not (str.in_re "a" re.empty)))
(simplify (not (str.in_re "aba" re.empty)))
(simplify (not (str.in_re "a" re.nostr)))
(simplify (str.in_re "a" re.all))
(simplify (str.in_re "aba" re.all))
(simplify (str.in_re "a" re.allchar))
(simplify (str.in_re "b" re.allchar))
(simplify (not (str.in_re "aba" re.allchar)))
(simplify (str.in_re "a" (re.range "a" "b")))
(simplify (str.in_re "b" (re.range "a" "b")))
(simplify (str.in_re "c" (re.range "c" "c")))
(simplify (not (str.in_re "c" (re.range "c" "b"))))
(simplify (not (str.in_re "c" (re.range "a" "b"))))
(simplify (not (str.in_re "aba" (re.range "a" "b"))))
(simplify (str.in_re "a" (str.to_re "a")))
(simplify (not (str.in_re "a" (str.to_re ""))))
(simplify (not (str.in_re "aba" (str.to_re "a"))))
(simplify (not (str.in_re "a" (str.to_re "b"))))
(simplify (not (str.in_re "aba" (str.to_re "ab"))))
(simplify (not (str.in_re "aba" (re.of.pred p))))
(echo "TODO: checks with nontrivial predicates")

(echo "= standard constructors =")
; option, union, concat, star, plus
(simplify (str.in_re "aba" (re.opt (str.to_re "aba"))))
(simplify (not (str.in_re "a" (re.opt (str.to_re "ab")))))
(simplify (not (str.in_re "a" (re.opt (str.to_re "b")))))
(simplify (str.in_re "a" (re.union r (str.to_re "a"))))
(simplify (not (str.in_re "ab" (re.union (str.to_re "a") (str.to_re "b")))))
(simplify (str.in_re "aba" (re.++ re.all (str.to_re "a"))))
(simplify (str.in_re "aba" (re.++ (str.to_re "aba") re.all)))
(simplify (str.in_re "aba" (re.++ re.allchar (str.to_re "ba"))))
(simplify (str.in_re "a" (re.++ (str.to_re "a") (re.opt r))))
(simplify (not (str.in_re "ba" (re.++ (str.to_re "") re.allchar))))
(simplify (not (str.in_re "a" (re.++ re.all re.empty))))
(simplify (not (str.in_re "b" (re.++ (str.to_re "a") (str.to_re "")))))
(simplify (str.in_re "aaa" (re.* (str.to_re "a"))))
(simplify (not (str.in_re "aba" (re.* (str.to_re "ab")))))
(simplify (str.in_re "aba" (re.* (str.to_re "aba"))))
(simplify (str.in_re "aba" (re.* re.allchar)))
(simplify (str.in_re "a" (re.+ re.all)))
(simplify (str.in_re "aaaaaa" (re.+ (str.to_re "aa"))))

(echo "= additional constructors =")
; additional constructors: complement, intersection
(simplify (str.in_re "aba" (re.complement re.allchar)))
(simplify (str.in_re "b" (re.complement re.empty)))
(simplify (str.in_re "a" (re.complement (str.to_re ""))))
(simplify (str.in_re "a" (re.complement (str.to_re "aba"))))
(simplify (str.in_re "aba" (re.complement (re.+ (str.to_re "a")))))
(simplify (not (str.in_re "a" (re.complement re.all))))
(simplify (not (str.in_re "b" (re.complement re.allchar))))
(simplify (not (str.in_re "a" (re.complement (str.to_re "a")))))
(simplify (str.in_re "a" (re.inter re.all (str.to_re "a"))))
(simplify (str.in_re "ab" (re.inter (str.to_re "ab") (str.to_re "ab"))))
(simplify (not (str.in_re "a" (re.inter (str.to_re "") r))))
(simplify (not (str.in_re "a" (re.inter (str.to_re "") re.allchar))))
(simplify (not (str.in_re "aba" (re.inter re.all (str.to_re "a")))))
(simplify (not (str.in_re "ab" (re.inter re.empty (str.to_re "ab")))))
(simplify (not (str.in_re "c" (re.inter (str.to_re "a") (str.to_re "b")))))

(echo "= looping (* with counting) =")
; loop types: iterate n times; iterate between m and n times; iterate at least m times
(simplify (str.in_re "a" ((_ re.loop 0) re.all)))
(simplify (str.in_re "aba" ((_ re.loop 3) re.all)))
(simplify (str.in_re "aa" ((_ re.loop 1 3) (str.to_re "a"))))
(simplify (str.in_re "bb" ((_ re.loop 0 2) (str.to_re "b"))))
(simplify (str.in_re "abab" ((_ re.loop 2 4) (str.to_re "ab"))))
(simplify (str.in_re "aa" ((_ re.loop 0) (str.to_re "aa"))))
(simplify (str.in_re "aa" ((_ re.loop 2) (str.to_re "a"))))
(simplify (str.in_re "aba" ((_ re.loop 3 3) re.allchar)))
(simplify (not (str.in_re "a" ((_ re.loop 0 0) r))))
(simplify (not (str.in_re "ab" ((_ re.loop 1 3) (str.to_re "a")))))
(simplify (not (str.in_re "b" ((_ re.loop 1 0) (str.to_re "b")))))
(simplify (not (str.in_re "aaa" ((_ re.loop 1 2) (str.to_re "a")))))
(simplify (not (str.in_re "aa" ((_ re.loop 3) re.allchar))))

(echo "= complex combinations =")
(simplify (str.in_re "aaaaaaa" (re.+ (re.union (str.to_re "aa") (str.to_re "aaa")))))
(simplify (not (str.in_re "aaaaaaa" (re.+ (re.union (str.to_re "aaa") (str.to_re "aaaaa"))))))
(echo "TODO")

(echo "=== using variable strings ===")
(echo "TODO")
